# VEP 19: 一种允许全节点不执行合约代码也能验证交易并构建合约状态的方案

## 背景

gvite的作用主要是维护本地存储的信息和提供查询，根据信息来源，节点存储的信息包括两类：

* 通过同步或者广播直接获取的块信息，包括快照块、账户块
* 通过块信息计算出来的状态信息，包括账户余额、合约状态、合约meta、合约代码、vmlog

状态信息又可以根据获取难度和重要性细分成三类：

* 利用账户块上的字段进行简单计算即可生成的数据，包括账户余额、合约meta
* 执行合约代码后生成并且会影响后续交易验证的信息，包括合约状态、合约代码
* 执行合约代码后生成并且不影响后续交易验证的信息，即vmlog

节点信息的应用场景主要包含以下几种：

* 维护账本：即验证账户块和快照块，需要使用除vmlog外的所有信息
* 其他节点同步时提供账本：快照块、账户块
* 超级节点出块：包括快照块和合约账户块，需要使用所有信息
* 发交易：需要使用账户块、账户余额、合约meta
* 链上数据查询：需要使用快照块、账户块，可能需要使用账户余额、合约状态、合约meta、合约代码、vmlog

其中，所有节点都需要维护本地账本，并在其他节点同步时提供账本信息，因此所有节点都需要存储除了vmlog外的其他信息。

根据节点的使用场景将节点分为以下三类：

* 超级节点：需要出块。配置要求高。
* 普通全节点：可以发交易，支持链上数据查询。配置要求比超级节点低。
* dApp节点：支持链上数据查询。配置要求低。

目前所有节点都需要通过执行合约代码的方式来验证合约响应交易，生成合约状态。实际上对于后两类配置较低的节点来说，没有必要全量验证合约响应交易，验证代价也比较高，应该允许这两类节点按需验证，同时又能按需构建出合约状态，那么就可以大大减轻这两类节点的计算和存储负担。

## 目标

允许部分全节点不执行合约代码也能验证交易并构建出合约状态，减轻这些全节点的计算和存储负担。

需要解决的两个问题：
* 如何在不执行代码的情况下获取最新状态。
* 如何信任新块（包括账户块和快照块）。

## 方案

### 如何在不执行代码的情况下获取最新状态

将执行合约代码后生成并且会影响后续交易验证的信息（即合约状态和合约代码，以下简称为状态变更信息）写入账户块中，并参与哈希计算。当全节点在收到合约账户块时，如果块上携带的状态变更信息和哈希一致，可以不执行合约代码，直接根据状态变更信息更新本地合约状态。

如果一个节点关注执行合约代码后生成并且不影响后续交易验证的信息（即vmlog），那么这个节点需要全量执行相关合约账户链上的所有响应交易，但是可以不执行其他合约账户链上的交易。

为了不增加节点的存储成本，所有节点在存储账户块时不保存状态变更信息。即新节点在同步过程中拿到的账户块中没有状态变更信息，收到广播的账户块时有状态变更信息，因此全节点在同步过程中需要按需执行合约代码。

对于三类节点：

* 超级节点：同步和广播时都需要全量执行合约代码，全量存储状态。
* 普通全节点：同步时需要全量执行合约代码，广播时按需验证账户块，全量存储状态。
* dApp节点：同步和广播时都按需执行合约代码，存储共识相关状态，按需存储其他合约状态。

所有的节点都需要全量存储快照块和账户块。节点同步时拉取的是块信息，因此本方案不影响各类节点间同步，也可以直接兼容旧数据。

对于dApp节点，当需要增加本地存储合约状态的账户时，可以直接用相应的账户链构建出完整的合约状态，重新执行一遍这条账户链上所有的交易即可。

在节点启动时，允许配置全量执行合约代码、按需执行合约代码、只执行指定合约的代码。

为了减少此方案可能导致的带宽消耗增加，实际实施时，允许超级节点根据实际情况决定是否在广播账户块时附加状态变更信息，例如根据执行代价、变更的数据量、和当前带宽使用情况判断，其他节点在接收到广播消息时，如果发现未携带状态变更信息，则按需执行合约代码即可。

### 如何信任新块

对于一个合约账户块的可信验证，如果这个合约块的字段正确（字段内容和哈希），依赖正确（哈希和高度依赖、请求交易和响应交易依赖、响应交易被快照依赖），签名符合共识，并且被快照块快照，那么这个块是可信的；如果前两个条件验证通过，但是没有被快照，那么这个块不一定是可信的，除非状态变更信息和执行合约代码后的结果一致。

对于一个快照块的可信验证，如果这个快照块的字段正确（字段内容和哈希），依赖正确（高度和哈希），快照的账户块可信（合约块只需要满足可信的前两个条件），签名符合共识，那么这个快照块可信，这个快照块快照的交易也可信。

对于共识，创世块对应的共识结果是可信的。如果前一轮的共识是可信的，那么这一轮的共识也是可信的。

用户账户块的可信验证逻辑不变。

